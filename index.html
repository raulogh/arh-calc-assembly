<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <title>Advanced ASM Simulator - BP & Infinite Regs</title>
    <style>
        :root { --bg: #1e1e1e; --panel: #252526; --accent: #007acc; --border: #3e3e42; --text: #d4d4d4; --success: #4ec9b0; --error: #f44336; }
        body { font-family: 'Segoe UI', Consolas, sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; background: var(--bg); color: var(--text); }
        
        /* Layout */
        .toolbar { background: #333; padding: 10px; display: flex; gap: 10px; border-bottom: 1px solid var(--border); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .main-container { display: flex; flex: 1; overflow: hidden; }
        .column { flex: 1; display: flex; flex-direction: column; padding: 10px; min-width: 0; }
        
        /* Editor */
        .editor-wrapper { flex: 1; position: relative; display: flex; flex-direction: column; }
        textarea { flex: 1; background: var(--panel); color: #dcdcdc; font-family: 'Consolas', monospace; font-size: 14px; border: 1px solid var(--border); padding: 10px; resize: none; outline: none; line-height: 1.5; }
        textarea:focus { border-color: var(--accent); }
        
        /* Terminal & Registers */
        #terminal { flex: 1; background: #111; color: #eee; font-family: 'Consolas', monospace; padding: 10px; overflow-y: auto; border: 1px solid var(--border); margin-top: 10px; font-size: 13px; }
        .log-entry { margin-bottom: 2px; border-bottom: 1px solid #222; padding: 2px 0; }
        .log-err { color: var(--error); font-weight: bold; }
        .log-sys { color: var(--success); }
        
        /* Grid Registre */
        .cpu-panel { background: #2d2d30; padding: 10px; border-radius: 4px; border: 1px solid var(--border); overflow-y: auto; max-height: 40vh; }
        .reg-section-title { font-size: 12px; text-transform: uppercase; color: #888; margin: 10px 0 5px 0; border-bottom: 1px solid #444; }
        .reg-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px; }
        .reg-box { background: #3e3e42; padding: 5px; border-radius: 3px; font-size: 13px; text-align: center; border: 1px solid transparent; }
        .reg-box.changed { animation: flash 0.5s; border-color: var(--success); }
        .reg-label { font-weight: bold; color: var(--accent); font-size: 11px; display: block; }
        .reg-val { font-family: monospace; color: white; }

        /* Buttons */
        button { cursor: pointer; padding: 8px 16px; border: none; border-radius: 3px; background: var(--accent); color: white; font-weight: 600; transition: background 0.2s; }
        button:hover { background: #0062a3; }
        button.reset { background: #a31515; }
        button.reset:hover { background: #801010; }

        @keyframes flash { 0% { background: #205c4b; } 100% { background: #3e3e42; } }
    </style>
</head>
<body>

<div class="toolbar">
    <button onclick="runProgram()">‚ñ∂ ExecutƒÉ Tot</button>
    <button onclick="loadExample('BP')">üìÇ Ex: Array cu BP</button>
    <button onclick="loadExample('INF')">üìÇ Ex: Registre Infinite</button>
    <button onclick="resetSystem()" class="reset">‚úñ Resetare</button>
</div>

<div class="main-container">
    <div class="column" style="flex: 1.2;">
        <h3>üìù Editor Assembly</h3>
        <div class="editor-wrapper">
            <textarea id="codeEditor" spellcheck="false" placeholder="// Scrie cod aici..."></textarea>
        </div>
    </div>

    <div class="column">
        <h3>‚ö° Stare Procesor</h3>
        <div class="cpu-panel">
            <div class="reg-section-title">Registre Principale</div>
            <div class="reg-grid" id="mainRegs"></div>
            
            <div class="reg-section-title">Pointeri & Flags</div>
            <div class="reg-grid" id="pointerRegs"></div>

            <div class="reg-section-title">Registre Generale (Dinamice)</div>
            <div class="reg-grid" id="dynamicRegs"></div>
        </div>

        <h3>üíª ConsolƒÉ Sistem</h3>
        <div id="terminal"></div>
    </div>
</div>

<script>
    // --- CONFIGURA»öIE CPU ---
    let CPU = {
        // Registre Standard
        AX: 0, BX: 0, CX: 0, DX: 0,
        // Pointeri
        BP: 0, // Base Pointer
        SP: 0, // Stack Pointer (neplementat logic stivƒÉ completƒÉ, dar existƒÉ ca reg)
        PC: 0, // Program Counter
        // Flags
        Z: 0, S: 0, 
        // Memorie »ôi Registre Infinite
        memory: {},     // HartƒÉ sparse pentru memorie
        R: {},          // Stocare pentru R0...Rn
        labels: {}
    };

    // Stare pentru UI (pentru a eviden»õia schimbƒÉrile)
    let oldCPU = JSON.parse(JSON.stringify(CPU));

    // --- UTILITARE PARSARE ---
    
    // Converte»ôte "10", "10H", "#10" √Æn numƒÉr
    function parseNumber(str) {
        if (!str) return 0;
        let s = str.replace('#', '').trim().toUpperCase();
        if (s.endsWith('H')) return parseInt(s.slice(0, -1), 16);
        return parseInt(s, 10);
    }

    // RezolvƒÉ adrese complexe: [BP+4], [100H], etc.
    // ReturneazƒÉ { type: 'MEM', addr: 123 } sau { type: 'REG', name: 'AX' } sau { type: 'IMM', val: 5 }
    function resolveOperand(op) {
        op = op.trim().toUpperCase();

        // 1. Adresare IndirectƒÉ / Memorie [...]
        if (op.startsWith('[') && op.endsWith(']')) {
            let content = op.slice(1, -1).replace(/\s+/g, ''); // EliminƒÉ spa»õii: BP+4
            
            // Calcul adresƒÉ
            let address = 0;
            
            // VerificƒÉm dacƒÉ con»õine un registru de bazƒÉ (BP, BX)
            let baseReg = null;
            let offsetStr = content;

            if (content.includes('BP')) { baseReg = 'BP'; offsetStr = content.replace('BP', ''); }
            else if (content.includes('BX')) { baseReg = 'BX'; offsetStr = content.replace('BX', ''); }
            
            // CalculƒÉm baza
            if (baseReg) address = CPU[baseReg];

            // CalculƒÉm offset-ul (ex: +4, -2, sau gol)
            if (offsetStr.length > 0) {
                if (offsetStr === '+') { /* eroare de sintaxƒÉ ignoratƒÉ, treat as 0 */ } 
                else {
                    // TratƒÉm +200H sau -5
                    // Hack simplu: folosim parseNumber dar gestionƒÉm semnul
                    let sign = 1;
                    if (offsetStr.startsWith('-')) { sign = -1; offsetStr = offsetStr.substring(1); }
                    else if (offsetStr.startsWith('+')) { offsetStr = offsetStr.substring(1); }
                    
                    address += sign * parseNumber(offsetStr);
                }
            } else if (!baseReg) {
                // Doar numƒÉr √Æn parantezƒÉ [100]
                address = parseNumber(content);
            }

            return { type: 'MEM', addr: address };
        }

        // 2. Imediat (#valoare)
        if (op.startsWith('#')) {
            return { type: 'IMM', val: parseNumber(op) };
        }

        // 3. Registre Dinamice (Rx)
        if (/^R\d+$/.test(op)) {
            return { type: 'DYN_REG', name: op };
        }

        // 4. Registre Standard (AX, BX, BP...)
        if (CPU.hasOwnProperty(op)) {
            return { type: 'REG', name: op };
        }

        // 5. Etichete sau Memorie directƒÉ fƒÉrƒÉ paranteze (op»õional, tratƒÉm ca valoare imediatƒÉ/adresƒÉ)
        // √én acest simulator, dacƒÉ e numƒÉr simplu fƒÉrƒÉ #, e considerat adresƒÉ doar √Æn context de JMP, 
        // dar pentru MOV AX, 100 -> unii asamblori zic Mem[100], al»õii Val 100.
        // Vom presupune cƒÉ 100 simplu este adresƒÉ pentru LOAD/STORE, dar valoare pentru MOV dacƒÉ nu are [].
        // Pentru consisten»õƒÉ cu exemplul dat: MOV 100H, AX -> 100H e adresƒÉ.
        // Vom returna MEM dacƒÉ e numeric.
        let val = parseNumber(op);
        if (!isNaN(val)) return { type: 'MEM', addr: val };

        return { type: 'ERR', val: op };
    }

    // Ia valoarea (pentru Source)
    function getValue(opStr) {
        let op = resolveOperand(opStr);
        if (op.type === 'IMM') return op.val;
        if (op.type === 'REG') return CPU[op.name];
        if (op.type === 'DYN_REG') return CPU.R[op.name] || 0;
        if (op.type === 'MEM') return CPU.memory[op.addr] || 0;
        throw new Error(`Operand necunoscut: ${opStr}`);
    }

    // SeteazƒÉ valoarea (pentru Destination)
    function setValue(opStr, val) {
        let op = resolveOperand(opStr);
        if (op.type === 'IMM') throw new Error("Nu po»õi scrie √Æntr-o constantƒÉ (#val)");
        if (op.type === 'REG') {
            CPU[op.name] = val;
        } else if (op.type === 'DYN_REG') {
            CPU.R[op.name] = val;
        } else if (op.type === 'MEM') {
            CPU.memory[op.addr] = val;
        } else {
            throw new Error(`Destina»õie invalidƒÉ: ${opStr}`);
        }
    }

    // --- EXECU»öIE ---

    function resetSystem() {
        CPU = { AX: 0, BX: 0, CX: 0, DX: 0, BP: 0, SP: 0, PC: 0, Z: 0, S: 0, memory: {}, R: {}, labels: {} };
        oldCPU = JSON.parse(JSON.stringify(CPU));
        document.getElementById('terminal').innerHTML = "<div class='log-sys'>System Reset. Ready.</div>";
        updateUI();
    }

    function runProgram() {
        const code = document.getElementById('codeEditor').value;
        const lines = code.split('\n');
        
        resetSystem();

        // Pas 1: Scanare Etichete
        lines.forEach((line, idx) => {
            let clean = line.split('//')[0].split(';')[0].trim();
            if (clean.endsWith(':')) {
                let labelName = clean.slice(0, -1);
                CPU.labels[labelName] = idx;
            }
        });

        // Pas 2: Execu»õie
        let steps = 0;
        try {
            while (CPU.PC < lines.length) {
                if (steps > 5000) throw new Error("Infinite Loop Protection (5000+ pa»ôi)");
                
                let currentLinePC = CPU.PC;
                executeInstruction(lines[CPU.PC], currentLinePC);
                
                // Increment PC doar dacƒÉ nu a fost modificat de un JUMP (simplificare)
                // √én realitate PC cre»ôte, apoi se face jump. Aici, instruc»õiunile JMP modificƒÉ direct PC-ul.
                // DacƒÉ PC-ul este acela»ôi cu cel de la √Ænceputul instruc»õiunii (»ôi nu e o linie goalƒÉ), √Æl incrementƒÉm.
                // Totu»ôi, JMP seteazƒÉ PC la noua valoare. 
                // Logica: DacƒÉ instruc»õiunea NU e JMP/CALL, PC++.
                // Dar executeInstruction se ocupƒÉ de PC doar la JMP.
                // Cea mai simplƒÉ metodƒÉ: salvƒÉm PC √Ænainte. DacƒÉ e diferit dupƒÉ execu»õie, nu facem nimic.
                
                if (CPU.PC === currentLinePC) {
                    CPU.PC++; 
                }
                steps++;
            }
            logTerminal("Execu»õie finalizatƒÉ cu succes.", "sys");
        } catch (e) {
            logTerminal(`Eroare Linia ${CPU.PC + 1}: ${e.message}`, "err");
        }
        updateUI();
    }

    function executeInstruction(rawLine, currentPC) {
        let line = rawLine.split('//')[0].split(';')[0].trim();
        if (!line || line.endsWith(':')) return; // Linii goale sau etichete

        // Regex inteligent pentru split: separƒÉ prin spa»õiu sau virgulƒÉ, ignorƒÉ spa»õii √Æn paranteze
        // Simplificare: √Ænlocuim virgula cu spa»õiu »ôi facem split
        // Pentru a pƒÉstra [BP + 4] unit, e complicat cu split simplu.
        // Vom face un mic parser manual pentru argumente.
        
        let firstSpace = line.indexOf(' ');
        if (firstSpace === -1) firstSpace = line.length;
        
        let cmd = line.substring(0, firstSpace).toUpperCase();
        let argsStr = line.substring(firstSpace).trim();
        
        // Split args by comma, but respect brackets
        let args = [];
        let currentArg = '';
        let bracketDepth = 0;
        
        for (let char of argsStr) {
            if (char === '[') bracketDepth++;
            if (char === ']') bracketDepth--;
            if (char === ',' && bracketDepth === 0) {
                args.push(currentArg.trim());
                currentArg = '';
            } else {
                currentArg += char;
            }
        }
        if (currentArg.trim()) args.push(currentArg.trim());

        let p1 = args[0];
        let p2 = args[1];

        switch (cmd) {
            case 'MOV':
                setValue(p1, getValue(p2));
                break;
            case 'ADD':
                let resAdd = getValue(p1) + getValue(p2);
                setValue(p1, resAdd);
                CPU.Z = (resAdd === 0) ? 1 : 0;
                break;
            case 'SUB':
                let resSub = getValue(p1) - getValue(p2);
                setValue(p1, resSub);
                CPU.Z = (resSub === 0) ? 1 : 0;
                break;
            case 'MUL':
                setValue(p1, getValue(p1) * getValue(p2));
                break;
            case 'DIV':
                let divisor = getValue(p2);
                if (divisor === 0) throw new Error("√émpƒÉr»õire la zero!");
                setValue(p1, Math.floor(getValue(p1) / divisor));
                break;
            case 'INC':
                let vInc = getValue(p1) + 1;
                setValue(p1, vInc);
                CPU.Z = (vInc === 0) ? 1 : 0;
                break;
            case 'DEC':
                let vDec = getValue(p1) - 1;
                setValue(p1, vDec);
                CPU.Z = (vDec === 0) ? 1 : 0;
                break;
            case 'CMP':
                let diff = getValue(p1) - getValue(p2);
                CPU.Z = (diff === 0) ? 1 : 0;
                CPU.S = (diff < 0) ? 1 : 0;
                break;
            case 'JMP':
                if (CPU.labels.hasOwnProperty(p1)) CPU.PC = CPU.labels[p1] - 1; // -1 pt cƒÉ bucla principalƒÉ face PC++
                else throw new Error(`EtichetƒÉ inexistentƒÉ: ${p1}`);
                break;
            case 'JZ':
            case 'JE':
                if (CPU.Z === 1) CPU.PC = CPU.labels[p1] - 1;
                break;
            case 'JNZ':
            case 'JNE':
                if (CPU.Z === 0) CPU.PC = CPU.labels[p1] - 1;
                break;
            case 'LOAD': // Alias pt MOV reg, mem
                // SuportƒÉ LOAD A, 200 (direct mem address)
                setValue('AX', CPU.memory[parseNumber(p1)] || 0); // Simplificare pt compatibilitate
                break;
            case 'STORE': // Alias
                CPU.memory[parseNumber(p1)] = CPU.AX;
                break;
            case 'OUT':
                logTerminal(`OUTPUT Port ${p1}: ${getValue(p1)} (Valoare)`, "sys");
                break;
            case 'HLT':
                CPU.PC = 99999; // Force stop
                break;
            default:
                throw new Error(`Instruc»õiune necunoscutƒÉ: ${cmd}`);
        }
    }

    // --- UI HELPERS ---

    function logTerminal(msg, type = "") {
        const t = document.getElementById('terminal');
        t.innerHTML += `<div class="log-entry log-${type}">> ${msg}</div>`;
        t.scrollTop = t.scrollHeight;
    }

    function createRegBox(label, val, oldVal) {
        let changed = val !== oldVal ? 'changed' : '';
        // FormatƒÉm hex dacƒÉ e mare, altfel decimal
        let display = val; 
        if (Math.abs(val) > 255) display = `0x${val.toString(16).toUpperCase()}`;
        
        return `<div class="reg-box ${changed}">
            <span class="reg-label">${label}</span>
            <span class="reg-val">${display}</span>
        </div>`;
    }

    function updateUI() {
        // 1. Registre Principale
        const main = ['AX', 'BX', 'CX', 'DX'];
        document.getElementById('mainRegs').innerHTML = main.map(r => createRegBox(r, CPU[r], oldCPU[r])).join('');

        // 2. Pointeri
        const ptrs = ['BP', 'SP', 'PC', 'Z'];
        document.getElementById('pointerRegs').innerHTML = ptrs.map(r => createRegBox(r, CPU[r], oldCPU[r])).join('');

        // 3. Registre Dinamice (doar cele folosite)
        let dynHTML = "";
        let keys = Object.keys(CPU.R).sort((a,b) => parseInt(a.slice(1)) - parseInt(b.slice(1))); // sort R1, R2, R10
        if (keys.length === 0) dynHTML = "<div style='color:#666; font-size:12px; padding:5px;'>Niciun registru Rx utilizat.</div>";
        else {
            keys.forEach(k => {
                dynHTML += createRegBox(k, CPU.R[k], oldCPU.R ? oldCPU.R[k] : 0);
            });
        }
        document.getElementById('dynamicRegs').innerHTML = dynHTML;

        // SalveazƒÉ starea pentru urmƒÉtorul update
        oldCPU = JSON.parse(JSON.stringify(CPU));
    }

    // --- EXEMPLE ---
    function loadExample(type) {
        let code = "";
        if (type === 'BP') {
            code = `// Simulare Array cu BP (Base Pointer)
// Vrem sa facem v[2] = 55
// Memoria incepe la adresa 100H

MOV BP, #100H  ; Setam baza la 100H
MOV AX, #55    ; Valoarea de salvat

// Scriem la BP + 2 (adica 102H)
MOV [BP + 2], AX 

// Verificam citirea inapoi in R1
MOV R1, [BP + 2]

// Incrementam indexul
ADD BP, #1
MOV [BP], #99  ; Scriem la 101H
`;
        } else if (type === 'INF') {
            code = `// Utilizare Registre Infinite
MOV R0, #10
MOV R99, #500
MOV R123, #1

ADD R0, R99  ; R0 devine 510
MOV R5000, R0 ; Putem folosi orice index
`;
        }
        document.getElementById('codeEditor').value = code;
        resetSystem();
    }

    // Init
    loadExample('BP');
</script>
</body>
</html>
